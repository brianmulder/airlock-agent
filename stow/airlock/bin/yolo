#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: yolo [options] [--] [command...]

Launch an ephemeral container with explicit mounts:
  - /host<host-path>      (rw)  workspace mount (repo root when inside git)
  - /home/airlock/.codex  (rw)  host ~/.codex
  - /home/airlock/.config/opencode (rw) host ~/.config/opencode
  - /home/airlock/.local/share/opencode (rw) host ~/.local/share/opencode
  - /home/airlock/.zshrc  (ro)  host ~/.airlock/config/zshrc
  - /home/airlock/.cache  (rw)  host ~/.airlock/cache
  - /home/airlock/.npm    (rw)  host ~/.airlock/cache/npm
  - /home/airlock/.local/share/pnpm (rw) host ~/.airlock/cache/pnpm

Examples:
  yolo
  yolo -- bash -lc 'id; mount | head'
  yolo -- codex --profile yolo
  yolo -- opencode
  yolo --publish 1455:1455 -- opencode auth login
  yolo --add-dir ~/tmp/airlock-writes -- codex --profile yolo
  yolo --mount-ro ~/tmp/inputs -- bash -lc 'ls -la /host$PWD'

Options:
  --add-dir <DIR>     Bind-mount host DIR read-write at /host<abs>.
                      If the command is `codex`, forwards as `--add-dir /host<abs>`.
  --mount-ro <DIR>    Bind-mount host DIR read-only at /host<abs>.
  --publish <SPEC>    Publish container port(s) to the host (passed to the engine as `-p SPEC`).
                      Example: --publish 1455:1455 (needed for some OAuth callbacks on WSL/Windows).
  --dind              Enable Docker-in-Docker (starts `dockerd` inside the container).
                      Implies `--no-engine-socket` and runs the container privileged.
  --engine-socket[=<0|1>]
                      Enable/disable mounting the host container engine socket (default: auto when available).
                      Use 0 to disable; use 1 to force-enable (when a socket exists).
  --no-engine-socket  Alias for --engine-socket=0.
  --name <NAME>       Container name override (default: airlock-<basename of $PWD>).
  --new               Start a new container if the default name is already running.
  -h, --help          Show this help.

Key env vars:
  AIRLOCK_ENGINE=podman|docker|nerdctl   Container engine command (default: podman)
  AIRLOCK_IMAGE=airlock-agent:local     Image tag to run
  AIRLOCK_NETWORK=host                  Opt-in host networking (default: bridge)
  AIRLOCK_USERNS=...                    Optional engine user namespace mode (advanced)
  AIRLOCK_RM=0                          Keep container after exit (default: remove)
  AIRLOCK_TTY=0                         Disable -it (auto when attached to a tty)
  AIRLOCK_TIMING=1                      Print coarse timing around engine run (also enables entrypoint timing)
  AIRLOCK_DRY_RUN=1                     Print the engine command and exit
  AIRLOCK_DIND=1                        Enable Docker-in-Docker (starts `dockerd` inside the container).
  AIRLOCK_DIND_STORAGE_DRIVER=vfs       Docker storage driver for DinD (default: vfs).
  AIRLOCK_DIND_DOCKERD_ARGS="..."       Extra args appended to `dockerd` (whitespace-split).
  AIRLOCK_CONFIG_DIR=...                Host Airlock config dir (default: ~/.airlock/config)
  AIRLOCK_ZSHRC=...                     Host zshrc to mount (default: ~/.airlock/config/zshrc)
  AIRLOCK_CONFIG_TOML=...               Optional TOML defaults (default: ~/.airlock/config.toml)
  AIRLOCK_PROFILE=dock|yolo             Optional profile name for config.toml overrides
  AIRLOCK_MOUNT_OPENCODE=0              Disable mounting host OpenCode state (default: enabled)
  AIRLOCK_MOUNT_ENGINE_SOCKET=0         Disable mounting the host engine socket (default: enabled when available)
  AIRLOCK_PODMAN_STORAGE_DRIVER=vfs     When using nested podman, force a storage driver (example: vfs)
  AIRLOCK_MOUNT_ROS=/a:/b               Extra read-only mounts (colon-separated host dirs)
  AIRLOCK_ADD_DIRS=/x:/y                Extra read-write mounts (colon-separated host dirs; forwarded to codex as --add-dir)
  AIRLOCK_PUBLISH_PORTS=1455:1455       Extra published ports (comma-separated; passed as `-p SPEC`)
  AIRLOCK_HOST_OPENCODE_CONFIG_DIR=...  Host OpenCode config dir (default: ~/.config/opencode)
  AIRLOCK_HOST_OPENCODE_DATA_DIR=...    Host OpenCode data dir (default: ~/.local/share/opencode)
USAGE
}

case "${1:-}" in
  -h|--help)
    usage
    exit 0
    ;;
esac

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
airlock_config="$script_dir/airlock-config"

if [[ -x "$airlock_config" ]]; then
  # shellcheck disable=SC1090
  eval "$("$airlock_config")"
fi

ADD_DIR_HOSTS=()
MOUNT_RO_HOSTS=()
PUBLISH_PORT_SPECS=()
YOLO_DIND=0
YOLO_NEW=0
YOLO_NAME_OVERRIDE=""
while (( $# > 0 )); do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --add-dir)
      [[ -n "${2:-}" ]] || { echo "ERROR: --add-dir requires a path" >&2; exit 1; }
      ADD_DIR_HOSTS+=("$2")
      shift 2
      ;;
    --add-dir=*)
      ADD_DIR_HOSTS+=("${1#--add-dir=}")
      shift
      ;;
    --mount-ro)
      [[ -n "${2:-}" ]] || { echo "ERROR: --mount-ro requires a path" >&2; exit 1; }
      MOUNT_RO_HOSTS+=("$2")
      shift 2
      ;;
    --mount-ro=*)
      MOUNT_RO_HOSTS+=("${1#--mount-ro=}")
      shift
      ;;
    --publish)
      [[ -n "${2:-}" ]] || { echo "ERROR: --publish requires a port spec (e.g., 1455:1455)" >&2; exit 1; }
      PUBLISH_PORT_SPECS+=("$2")
      shift 2
      ;;
    --publish=*)
      PUBLISH_PORT_SPECS+=("${1#--publish=}")
      shift
      ;;
    --name)
      [[ -n "${2:-}" ]] || { echo "ERROR: --name requires a value" >&2; exit 1; }
      YOLO_NAME_OVERRIDE="$2"
      shift 2
      ;;
    --name=*)
      YOLO_NAME_OVERRIDE="${1#--name=}"
      shift
      ;;
    --engine-socket)
      AIRLOCK_MOUNT_ENGINE_SOCKET=1
      shift
      ;;
    --engine-socket=*)
      engine_socket_mode="${1#--engine-socket=}"
      case "$engine_socket_mode" in
        0|1) AIRLOCK_MOUNT_ENGINE_SOCKET="$engine_socket_mode" ;;
        *)
          echo "ERROR: --engine-socket expects 0 or 1 (got: $engine_socket_mode)" >&2
          exit 1
          ;;
      esac
      shift
      ;;
    --no-engine-socket)
      AIRLOCK_MOUNT_ENGINE_SOCKET=0
      shift
      ;;
    --dind)
      YOLO_DIND=1
      shift
      ;;
    --new)
      YOLO_NEW=1
      shift
      ;;
    --)
      shift
      break
      ;;
    --*)
      echo "ERROR: unknown option: $1" >&2
      echo "Hint: use -- to separate yolo options from the container command." >&2
      exit 1
      ;;
    *)
      break
      ;;
  esac
done

if [[ -n "${AIRLOCK_PROFILE:-}" && -z "${AIRLOCK_MOUNT_ENGINE_SOCKET+x}" ]]; then
  case "$AIRLOCK_PROFILE" in
    dock)
      AIRLOCK_MOUNT_ENGINE_SOCKET=0
      ;;
    yolo)
      AIRLOCK_MOUNT_ENGINE_SOCKET=1
      ;;
  esac
fi

AIRLOCK_ENGINE="${AIRLOCK_ENGINE:-podman}"
AIRLOCK_IMAGE="${AIRLOCK_IMAGE:-airlock-agent:local}"
AIRLOCK_RUN_AS_HOST_USER="${AIRLOCK_RUN_AS_HOST_USER:-1}"

ENGINE_NAME="$(basename "$AIRLOCK_ENGINE")"

# Hot-zone runtime state (host-local, RW)
AIRLOCK_HOME="${AIRLOCK_HOME:-$HOME/.airlock}"
CACHE_DIR="${CACHE_DIR:-$AIRLOCK_HOME/cache}"
AIRLOCK_CONFIG_DIR="${AIRLOCK_CONFIG_DIR:-$AIRLOCK_HOME/config}"

# Config files (stowed)
AIRLOCK_ZSHRC="${AIRLOCK_ZSHRC:-$AIRLOCK_CONFIG_DIR/zshrc}"

# Workspace (bind-mounted to /host<abs>). If inside a git repo, mount the repo root so `.git/` is available.
WORK_DIR="$(pwd)"
HOST_WORK_DIR="$WORK_DIR"
if [[ "${AIRLOCK_YOLO:-0}" == "1" && "$HOST_WORK_DIR" == /host/* ]]; then
  HOST_WORK_DIR="${HOST_WORK_DIR#/host}"
fi
WORK_MOUNT_SRC="$WORK_DIR"
if command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  git_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
  if [[ -n "$git_root" && -d "$git_root" ]]; then
    WORK_MOUNT_SRC="$git_root"
  fi
fi
HOST_WORK_MOUNT_SRC="$WORK_MOUNT_SRC"
if [[ "${AIRLOCK_YOLO:-0}" == "1" && "$HOST_WORK_MOUNT_SRC" == /host/* ]]; then
  HOST_WORK_MOUNT_SRC="${HOST_WORK_MOUNT_SRC#/host}"
fi

# Canonical workdir path (helps tools like Codex disambiguate sessions across repos).
CANON_MOUNT_TARGET="/host$HOST_WORK_MOUNT_SRC"
CANON_CONTAINER_WD="/host$HOST_WORK_DIR"

# Identity
HOST_UID="$(id -u)"
HOST_GID="$(id -g)"
AIRLOCK_UID="$HOST_UID"
AIRLOCK_GID="$HOST_GID"
AIRLOCK_USER_NAME="$(id -un 2>/dev/null || true)"
[[ -n "$AIRLOCK_USER_NAME" ]] || AIRLOCK_USER_NAME="$AIRLOCK_UID"

# Optional: keep the container running as root (useful for debugging). Default is to map to the host user
# at runtime via the container entrypoint.
if [[ "$AIRLOCK_RUN_AS_HOST_USER" == "0" ]]; then
  AIRLOCK_UID=0
  AIRLOCK_GID=0
fi

command -v "$AIRLOCK_ENGINE" >/dev/null || {
  echo "ERROR: container engine not found: $AIRLOCK_ENGINE"
  echo "Set AIRLOCK_ENGINE=docker|podman|nerdctl (or adjust PATH)."
  exit 1
}

req_dir() { [[ -d "$1" ]] || { echo "ERROR: missing directory: $1" >&2; exit 1; }; }
req_file() { [[ -f "$1" ]] || { echo "ERROR: missing file: $1" >&2; exit 1; }; }
warn() { echo "WARN: $*" >&2; }

req_file "$AIRLOCK_ZSHRC"

HOST_CODEX_DIR="${AIRLOCK_HOST_CODEX_DIR:-$HOME/.codex}"
mkdir -p "$HOST_CODEX_DIR"
CODEX_MOUNT_SRC="$HOST_CODEX_DIR"
CODEX_HOME_LABEL="$HOST_CODEX_DIR (rw)"

# OpenCode (host state mounted into container by default)
HOST_OPENCODE_CONFIG_DIR="${AIRLOCK_HOST_OPENCODE_CONFIG_DIR:-$HOME/.config/opencode}"
HOST_OPENCODE_DATA_DIR="${AIRLOCK_HOST_OPENCODE_DATA_DIR:-$HOME/.local/share/opencode}"

hostify_mount_src() {
  local p="$1"
  if [[ "${AIRLOCK_YOLO:-0}" == "1" && "$p" == /host/* ]]; then
    echo "${p#/host}"
  else
    echo "$p"
  fi
}

HOST_CODEX_MOUNT_SRC="$(hostify_mount_src "$CODEX_MOUNT_SRC")"
HOST_OPENCODE_CONFIG_MOUNT_SRC="$(hostify_mount_src "$HOST_OPENCODE_CONFIG_DIR")"
HOST_OPENCODE_DATA_MOUNT_SRC="$(hostify_mount_src "$HOST_OPENCODE_DATA_DIR")"
HOST_CACHE_DIR="$(hostify_mount_src "$CACHE_DIR")"
HOST_CACHE_DIR_NPM="$(hostify_mount_src "$CACHE_DIR/npm")"
HOST_CACHE_DIR_PNPM="$(hostify_mount_src "$CACHE_DIR/pnpm")"
HOST_AIRLOCK_ZSHRC="$(hostify_mount_src "$AIRLOCK_ZSHRC")"

# Prepare runtime dirs (avoid Docker creating root-owned dirs on host)
mkdir -p "$CODEX_MOUNT_SRC" "$CACHE_DIR" "$CACHE_DIR/npm" "$CACHE_DIR/pnpm"

if [[ "${AIRLOCK_MOUNT_OPENCODE:-1}" != "0" ]]; then
  mkdir -p "$HOST_OPENCODE_CONFIG_DIR" "$HOST_OPENCODE_DATA_DIR"
fi

# Guard rails: if your host Codex state is unreadable (often due to an accidental `sudo codex`),
# yolo will run but Codex will fail. Warn early; fail only when actually running codex.
check_host_codex_state() {
  [[ -n "$HOST_CODEX_DIR" ]] || return 0

  if [[ ! -d "$HOST_CODEX_DIR" ]]; then
    warn "host Codex dir missing: $HOST_CODEX_DIR (unexpected; yolo should have created it)"
    return 0
  fi

  if [[ ! -r "$HOST_CODEX_DIR" || ! -w "$HOST_CODEX_DIR" || ! -x "$HOST_CODEX_DIR" ]]; then
    warn "host Codex dir not accessible (need r/w/x): $HOST_CODEX_DIR"
    warn "Fix: sudo chown -R \"$AIRLOCK_USER_NAME\":\"$AIRLOCK_USER_NAME\" \"$HOST_CODEX_DIR\""
    return 0
  fi

  local cfg="$HOST_CODEX_DIR/config.toml"
  if [[ -e "$cfg" && ! -r "$cfg" ]]; then
    warn "host Codex config not readable: $cfg"
    warn "This usually means Codex was run as root at least once."
    warn "Fix: sudo chown -R \"$AIRLOCK_USER_NAME\":\"$AIRLOCK_USER_NAME\" \"$HOST_CODEX_DIR\""
    return 0
  fi
}

check_host_codex_state_or_die_for_codex() {
  [[ -n "$HOST_CODEX_DIR" ]] || return 0

  local cfg="$HOST_CODEX_DIR/config.toml"
  if [[ -e "$cfg" && ! -r "$cfg" ]]; then
    echo "ERROR: host Codex config not readable: $cfg" >&2
    echo "Hint: this usually means Codex was run as root at least once." >&2
    echo "Fix: sudo chown -R \"$AIRLOCK_USER_NAME\":\"$AIRLOCK_USER_NAME\" \"$HOST_CODEX_DIR\"" >&2
    exit 1
  fi
}

# Guard rails: host OpenCode state can also become unreadable if files were created as root.
check_host_opencode_state() {
  [[ "${AIRLOCK_MOUNT_OPENCODE:-1}" != "0" ]] || return 0
  [[ -n "$HOST_OPENCODE_DATA_DIR" ]] || return 0

  if [[ ! -d "$HOST_OPENCODE_DATA_DIR" ]]; then
    warn "host OpenCode data dir missing: $HOST_OPENCODE_DATA_DIR (unexpected; yolo should have created it)"
    return 0
  fi

  if [[ ! -r "$HOST_OPENCODE_DATA_DIR" || ! -w "$HOST_OPENCODE_DATA_DIR" || ! -x "$HOST_OPENCODE_DATA_DIR" ]]; then
    warn "host OpenCode data dir not accessible (need r/w/x): $HOST_OPENCODE_DATA_DIR"
    warn "Fix: sudo chown -R \"$AIRLOCK_USER_NAME\":\"$AIRLOCK_USER_NAME\" \"$HOST_OPENCODE_DATA_DIR\""
    return 0
  fi

  local auth="$HOST_OPENCODE_DATA_DIR/auth.json"
  if [[ -e "$auth" && ! -r "$auth" ]]; then
    warn "host OpenCode auth not readable: $auth"
    warn "This usually means OpenCode was run as root at least once."
    warn "Fix: sudo chown -R \"$AIRLOCK_USER_NAME\":\"$AIRLOCK_USER_NAME\" \"$HOST_OPENCODE_DATA_DIR\""
    return 0
  fi
}

check_host_opencode_state_or_die_for_opencode() {
  [[ "${AIRLOCK_MOUNT_OPENCODE:-1}" != "0" ]] || return 0
  [[ -n "$HOST_OPENCODE_DATA_DIR" ]] || return 0

  local auth="$HOST_OPENCODE_DATA_DIR/auth.json"
  if [[ -e "$auth" && ! -r "$auth" ]]; then
    echo "ERROR: host OpenCode auth not readable: $auth" >&2
    echo "Hint: this usually means OpenCode was run as root at least once." >&2
    echo "Fix: sudo chown -R \"$AIRLOCK_USER_NAME\":\"$AIRLOCK_USER_NAME\" \"$HOST_OPENCODE_DATA_DIR\"" >&2
    exit 1
  fi
}

# Interactive args (allocates a tty only when attached to one, unless disabled).
TTY_ARGS=()
if [[ "${AIRLOCK_TTY:-}" != "0" ]] && [[ -t 0 && -t 1 ]]; then
  TTY_ARGS=(-it)
fi

# Docker-in-Docker (opt-in): start `dockerd` inside the container.
#
# Note: this is intentionally not the default; it typically requires --privileged, and does not rely on
# mounting the host engine socket.
dind_enabled=0
if [[ "${AIRLOCK_DIND:-0}" != "0" || "$YOLO_DIND" == "1" ]]; then
  dind_enabled=1
  AIRLOCK_MOUNT_ENGINE_SOCKET=0
  AIRLOCK_DIND_STORAGE_DRIVER="${AIRLOCK_DIND_STORAGE_DRIVER:-vfs}"
fi

# Remove container by default (set AIRLOCK_RM=0 to keep it).
RM_ARGS=()
if [[ "${AIRLOCK_RM:-1}" != "0" ]]; then
  RM_ARGS=(--rm)
fi

# Name (override for smoke tests / parallel runs)
if [[ -n "$YOLO_NAME_OVERRIDE" ]]; then
  AIRLOCK_CONTAINER_NAME="$YOLO_NAME_OVERRIDE"
else
  AIRLOCK_CONTAINER_NAME="${AIRLOCK_CONTAINER_NAME:-airlock-$(basename "$WORK_DIR")}"
fi

new_container_name() {
  local base="$1"
  local suffix
  suffix="$(date +%s 2>/dev/null || true)"
  suffix="${suffix:-now}-$RANDOM-$$"
  echo "${base}-${suffix}"
}

# Optional host networking
NETWORK_ARGS=()
if [[ "${AIRLOCK_NETWORK:-}" == "host" ]]; then
  NETWORK_ARGS+=(--network host)
fi

# Engine-specific user namespace settings (primarily for Podman bind-mount ownership ergonomics).
USERNS_ARGS=()
if [[ -n "${AIRLOCK_USERNS:-}" ]]; then
  USERNS_ARGS+=(--userns="$AIRLOCK_USERNS")
fi

USER_ARGS=()

split_colon_list() {
  local raw="$1"
  local -n out="$2"
  local entry
  IFS=':' read -r -a out <<<"$raw"
  # Drop empty entries (e.g., leading/trailing colon)
  local cleaned=()
  for entry in "${out[@]}"; do
    [[ -n "$entry" ]] && cleaned+=("$entry")
  done
  out=("${cleaned[@]}")
}

split_comma_list() {
  local raw="$1"
  local -n out_list="$2"
  local entry
  IFS=',' read -r -a out_list <<<"$raw"
  # Drop empty entries (e.g., leading/trailing comma)
  local cleaned=()
  for entry in "${out_list[@]}"; do
    [[ -n "$entry" ]] && cleaned+=("$entry")
  done
  out_list=("${cleaned[@]}")
}

ENV_ADD_DIR_HOSTS=()
ENV_MOUNT_RO_HOSTS=()
ENV_PUBLISH_PORT_SPECS=()
if [[ -n "${AIRLOCK_ADD_DIRS:-}" ]]; then
  split_colon_list "$AIRLOCK_ADD_DIRS" ENV_ADD_DIR_HOSTS
fi
if [[ -n "${AIRLOCK_MOUNT_ROS:-}" ]]; then
  split_colon_list "$AIRLOCK_MOUNT_ROS" ENV_MOUNT_RO_HOSTS
fi
if [[ -n "${AIRLOCK_PUBLISH_PORTS:-}" ]]; then
  split_comma_list "$AIRLOCK_PUBLISH_PORTS" ENV_PUBLISH_PORT_SPECS
fi

extra_mounts=()
codex_add_dirs=()
for d in "${ENV_MOUNT_RO_HOSTS[@]}" "${MOUNT_RO_HOSTS[@]}"; do
  [[ -d "$d" ]] || { echo "ERROR: --mount-ro is not a directory: $d" >&2; exit 1; }
  abs="$(cd "$d" && pwd -P)"
  host_abs="$abs"
  if [[ "${AIRLOCK_YOLO:-0}" == "1" && "$host_abs" == /host/* ]]; then
    host_abs="${host_abs#/host}"
  fi
  target="/host$host_abs"
  extra_mounts+=(-v "$host_abs":"$target":ro)
done
for d in "${ENV_ADD_DIR_HOSTS[@]}" "${ADD_DIR_HOSTS[@]}"; do
  [[ -d "$d" ]] || { echo "ERROR: --add-dir is not a directory: $d" >&2; exit 1; }
  abs="$(cd "$d" && pwd -P)"
  host_abs="$abs"
  if [[ "${AIRLOCK_YOLO:-0}" == "1" && "$host_abs" == /host/* ]]; then
    host_abs="${host_abs#/host}"
  fi
  target="/host$host_abs"
  extra_mounts+=(-v "$host_abs":"$target":rw)
  codex_add_dirs+=(--add-dir "$target")
done

PUBLISH_PORT_ARGS=()
PUBLISH_PORTS_ALL=("${ENV_PUBLISH_PORT_SPECS[@]}" "${PUBLISH_PORT_SPECS[@]}")
for spec in "${PUBLISH_PORTS_ALL[@]}"; do
  [[ -n "$spec" ]] || continue
  PUBLISH_PORT_ARGS+=(-p "$spec")
done

is_codex_cmd() {
  local cmd="${1:-}"
  [[ "$cmd" == "codex" || "$cmd" == */codex ]]
}

is_opencode_cmd() {
  local cmd="${1:-}"
  [[ "$cmd" == "opencode" || "$cmd" == */opencode ]]
}

yolo_cmd=("$@")
if (( ${#yolo_cmd[@]} > 0 )) && is_codex_cmd "${yolo_cmd[0]}"; then
  check_host_codex_state_or_die_for_codex
else
  check_host_codex_state
fi
if (( ${#yolo_cmd[@]} > 0 )) && is_opencode_cmd "${yolo_cmd[0]}"; then
  check_host_opencode_state_or_die_for_opencode
else
  check_host_opencode_state
fi
if (( ${#yolo_cmd[@]} > 0 )) && is_codex_cmd "${yolo_cmd[0]}" && (( ${#codex_add_dirs[@]} > 0 )); then
  yolo_cmd=("${yolo_cmd[0]}" "${codex_add_dirs[@]}" "${yolo_cmd[@]:1}")
fi

has_extra_config=0
if [[ "$dind_enabled" == "1" || -n "${AIRLOCK_ADD_DIRS:-}" || -n "${AIRLOCK_MOUNT_ROS:-}" || -n "${AIRLOCK_PUBLISH_PORTS:-}" || "${#ADD_DIR_HOSTS[@]}" -gt 0 || "${#MOUNT_RO_HOSTS[@]}" -gt 0 || "${#PUBLISH_PORT_SPECS[@]}" -gt 0 ]]; then
  has_extra_config=1
fi

print_summary() {
  local name="$1"
  echo "--- Airlock YOLO ---"
  echo "Engine:     $AIRLOCK_ENGINE"
  echo "Image:      $AIRLOCK_IMAGE"
  echo "Workspace:  $WORK_DIR (mounted: $HOST_WORK_MOUNT_SRC) -> $CANON_MOUNT_TARGET (rw)"
  echo "Workdir:    $CANON_CONTAINER_WD"
  echo "CODEX_HOME: /home/airlock/.codex <= $CODEX_HOME_LABEL"
  if [[ "${AIRLOCK_MOUNT_OPENCODE:-1}" != "0" ]]; then
    echo "OpenCode:   /home/airlock/.config/opencode <= $HOST_OPENCODE_CONFIG_DIR (rw)"
    echo "            /home/airlock/.local/share/opencode <= $HOST_OPENCODE_DATA_DIR (rw)"
  fi
  if [[ "${#PUBLISH_PORT_ARGS[@]}" -gt 0 ]]; then
    echo "Ports:      ${PUBLISH_PORTS_ALL[*]}"
  fi
  if [[ "$dind_enabled" == "1" ]]; then
    echo "DinD:       enabled (docker storage driver: ${AIRLOCK_DIND_STORAGE_DRIVER:-<unset>})"
  fi
  if [[ "$has_extra_config" == "1" ]]; then
    echo "Extras:     (see mounts/ports in dry-run or engine output)"
  fi
  echo "Network:    ${AIRLOCK_NETWORK:-bridge}"
  echo "Name:       $name"
  echo "---------------------"
}

engine_container_exists() {
  local name="$1"
  "$AIRLOCK_ENGINE" inspect "$name" >/dev/null 2>&1
}

engine_container_running() {
  local name="$1"
  local running
  running="$("$AIRLOCK_ENGINE" inspect -f '{{.State.Running}}' "$name" 2>/dev/null || true)"
  [[ "$running" == "true" ]]
}

attach_to_running_container() {
  local name="$1"
  local exec_cmd=("$AIRLOCK_ENGINE" exec "${TTY_ARGS[@]}" -w "$CANON_CONTAINER_WD")

  if [[ "$AIRLOCK_RUN_AS_HOST_USER" != "0" ]]; then
    exec_cmd+=(--user "$AIRLOCK_UID:$AIRLOCK_GID")
  fi

  exec_cmd+=(
    -e "HOME=/home/airlock"
    -e "CODEX_HOME=/home/airlock/.codex"
    "$name"
  )

  if (( ${#yolo_cmd[@]} > 0 )); then
    exec_cmd+=("${yolo_cmd[@]}")
  else
    exec_cmd+=(zsh -l)
  fi

  print_summary "$name"
  echo "INFO: container is already running; attaching: $name" >&2
  exec "${exec_cmd[@]}"
}

if [[ "${AIRLOCK_DRY_RUN:-0}" != "1" ]]; then
  if engine_container_exists "$AIRLOCK_CONTAINER_NAME"; then
    if engine_container_running "$AIRLOCK_CONTAINER_NAME"; then
      if [[ "$YOLO_NEW" == "1" ]]; then
        AIRLOCK_CONTAINER_NAME="$(new_container_name "$AIRLOCK_CONTAINER_NAME")"
        echo "INFO: name already in use; starting new container: $AIRLOCK_CONTAINER_NAME" >&2
      else
        if [[ "$has_extra_config" == "1" ]]; then
          echo "ERROR: container is already running and cannot be modified with new mounts/ports." >&2
          echo "Hint: use --new (or set AIRLOCK_CONTAINER_NAME=...) to start a second container." >&2
          exit 1
        fi
        attach_to_running_container "$AIRLOCK_CONTAINER_NAME"
      fi
    else
      if [[ "$YOLO_NEW" == "1" ]]; then
        AIRLOCK_CONTAINER_NAME="$(new_container_name "$AIRLOCK_CONTAINER_NAME")"
        echo "INFO: name already exists (stopped); starting new container: $AIRLOCK_CONTAINER_NAME" >&2
      else
        echo "INFO: removing existing stopped container: $AIRLOCK_CONTAINER_NAME" >&2
        "$AIRLOCK_ENGINE" rm "$AIRLOCK_CONTAINER_NAME" >/dev/null 2>&1 || true
      fi
    fi
  fi
fi

print_summary "$AIRLOCK_CONTAINER_NAME"

cmd=(
  "$AIRLOCK_ENGINE" run
  "${TTY_ARGS[@]}"
  "${RM_ARGS[@]}"
  "${NETWORK_ARGS[@]}"
  "${PUBLISH_PORT_ARGS[@]}"
  "${USERNS_ARGS[@]}"
  "${USER_ARGS[@]}"
  --name "$AIRLOCK_CONTAINER_NAME"
  -e "AIRLOCK_UID=$AIRLOCK_UID"
  -e "AIRLOCK_GID=$AIRLOCK_GID"
  -e "AIRLOCK_YOLO=1"
  -e "AIRLOCK_TIMING=${AIRLOCK_TIMING:-0}"
  -e "AIRLOCK_DIND=$dind_enabled"
  -e "AIRLOCK_DIND_STORAGE_DRIVER=${AIRLOCK_DIND_STORAGE_DRIVER:-}"
  -e "AIRLOCK_DIND_DOCKERD_ARGS=${AIRLOCK_DIND_DOCKERD_ARGS:-}"
  -e "HOME=/home/airlock"
  -e "CODEX_HOME=/home/airlock/.codex"
  -w "$CANON_CONTAINER_WD"
  -v "$HOST_WORK_MOUNT_SRC":"$CANON_MOUNT_TARGET":rw
  -v "$HOST_CODEX_MOUNT_SRC":/home/airlock/.codex:rw
  -v "$HOST_CACHE_DIR":/home/airlock/.cache:rw
  -v "$HOST_CACHE_DIR_NPM":/home/airlock/.npm:rw
  -v "$HOST_CACHE_DIR_PNPM":/home/airlock/.local/share/pnpm:rw
  -v "$HOST_AIRLOCK_ZSHRC":/home/airlock/.zshrc:ro
)

if [[ -n "${AIRLOCK_PODMAN_STORAGE_DRIVER:-}" ]]; then
  cmd+=(-e "AIRLOCK_PODMAN_STORAGE_DRIVER=$AIRLOCK_PODMAN_STORAGE_DRIVER")
fi

cmd+=(-e "AIRLOCK_GIT_SAFE_DIRS=$CANON_MOUNT_TARGET")

if [[ "${AIRLOCK_MOUNT_OPENCODE:-1}" != "0" ]]; then
  cmd+=(
    -v "$HOST_OPENCODE_CONFIG_MOUNT_SRC":/home/airlock/.config/opencode:rw
    -v "$HOST_OPENCODE_DATA_MOUNT_SRC":/home/airlock/.local/share/opencode:rw
  )
fi

# Engine socket passthrough (to allow building/running containers from within yolo).
ENGINE_SOCKET_MOUNTS=()
ENGINE_SOCKET_ENVS=()

if [[ "${AIRLOCK_MOUNT_ENGINE_SOCKET:-1}" != "0" ]]; then
  if [[ "$ENGINE_NAME" == "docker" ]]; then
    if [[ -S /var/run/docker.sock ]]; then
      ENGINE_SOCKET_MOUNTS+=(-v /var/run/docker.sock:/var/run/docker.sock:rw)
      ENGINE_SOCKET_ENVS+=(-e DOCKER_HOST=unix:///var/run/docker.sock)
    fi
  elif [[ "$ENGINE_NAME" == "podman" ]]; then
    sock_host=""
    for candidate in \
      "/run/podman/podman.sock" \
      "${XDG_RUNTIME_DIR:-/run/user/$HOST_UID}/podman/podman.sock" \
      "/run/user/$HOST_UID/podman/podman.sock"
    do
      if [[ -S "$candidate" ]]; then
        sock_host="$candidate"
        break
      fi
    done
    if [[ -n "$sock_host" ]]; then
      ENGINE_SOCKET_MOUNTS+=(-v "$sock_host":/run/podman/podman.sock:rw)
      ENGINE_SOCKET_ENVS+=(-e CONTAINER_HOST=unix:///run/podman/podman.sock)
      ENGINE_SOCKET_ENVS+=(-e DOCKER_HOST=unix:///run/podman/podman.sock)
    fi
  fi
fi

cmd+=("${extra_mounts[@]}")
cmd+=("${ENGINE_SOCKET_MOUNTS[@]}")
cmd+=("${ENGINE_SOCKET_ENVS[@]}")

if [[ "$dind_enabled" == "1" ]]; then
  cmd+=(--privileged)
fi

cmd+=("$AIRLOCK_IMAGE")

if (( ${#yolo_cmd[@]} > 0 )); then
  cmd+=("${yolo_cmd[@]}")
fi

if [[ "${AIRLOCK_DRY_RUN:-0}" == "1" ]]; then
  printf 'CMD:'
  printf ' %q' "${cmd[@]}"
  printf '\n'
  exit 0
fi

if [[ "${AIRLOCK_TIMING:-0}" == "1" ]]; then
  host_start="$(date -Iseconds 2>/dev/null || true)"
  start_ns="$(date +%s%N 2>/dev/null || true)"
  echo "TIMING: host start: ${host_start:-unknown}" >&2
fi

"${cmd[@]}"

if [[ "${AIRLOCK_TIMING:-0}" == "1" ]]; then
  end_ns="$(date +%s%N 2>/dev/null || true)"
  if [[ -n "${start_ns:-}" && -n "${end_ns:-}" ]]; then
    elapsed_ms="$(( (end_ns - start_ns) / 1000000 ))"
    echo "TIMING: host end: +${elapsed_ms}ms" >&2
  else
    host_end="$(date -Iseconds 2>/dev/null || true)"
    echo "TIMING: host end: ${host_end:-unknown}" >&2
  fi
fi
